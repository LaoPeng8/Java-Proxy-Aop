# Jdk动态代理使用与原理分析

> 作者: LaoPeng
>
> 2022/7/22 18:24 始

动态代理：基于反射机制
1. 知道什么是动态代理?
   * 使用jdk的反射机制, 创建对象的能力, 创建的是代理类的对象. 而不用创建java文件
   * 动态: 在程序执行时, 调用jdk提供的方法才能创建代理类对象.
2. 知道动态代理能做为什么?
   * 在不改变原有代码的基础上, 新增功能

## 生活中的代理
代理，中介，换ip，商家等等  
比如有一家美国的大学，可以对世界招生。留学中介（代理）  
留学中介（代理）：帮助这家美国的学校招生，中介是学校的代理，中介是代替学校完成招生功能。

代理特点
1. 中介和代理他们要做的事情是一致的：招生
2. 中介是学校代理，学校是目标
3. 家长---中介（学校介绍，办理入学手续）----美国学校
4. 中介是代理，不能白干活，需要收取费用。
5. 代理不让你直接访问目标。

为什么要找中介？
1. 中介是专业的，方便
2. 家长现在不能自己去找学校。家长没有能力访问学校。或者美国的学校不接受个人访问。

买东西都是商家卖，商家是某个商品的代理，你个人买东西，肯定不会让你接触到厂家的。

## 开发中的代理
在开发中也会有这样的情况，你有a类，本来是调用c类的方法，完成某个功能。但是c不让a调用。

a --- 不能直接访问 c的方法  
在 a 与 c 之间 创建一个 b 代理。 c 让 b访问<br/>
a --- b --- c (a 通过b访问 c)

实际的例子：登录，注册有验证码，验证码是手机短信  
中国移动，联通能发短信。（但是不接受个人每天发个几条短信的）  
中国移动，联通有子公司 或者 关联公司，他们面向社会提供短信的发送能功能  
张三的项目发送短息 --- 子公司 或者 关联公司 --- 中国移动，联通

代理模式是指：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象则在客户类与目标对象之间起到中介的作用

换句话说，使用代理对象，是为了在**不修改目标对象的基础上，增强主业务逻辑**。

客户类真正想要访问的对象是目标对象，但是实际访问的是代理对象，那么代理对象就可以在访问目标对象前，后 实现自己的逻辑，以达到**不修改目标对象的基础上，增强主业务逻辑** 
（前置通知，后置通知就是这样）当然，代理类与目标类要实现同一个接口。

## 代理模式的作用
1. 功能增强：在原有的功能上，增加额外的功能。（不修改原有目标类）新增加的功能叫功能增强。（平时使用代理主要完成这个功能）
2. 控制访问：代理类不让你访问目标，例如商家不让用户访问厂家。

## 实现代理的方式
1. 静态代理：
    * 代理类是自己手工实现，自己创建一个java类，表示代理类
    * 同时 要代理的目标是确定的
    * 特点：实现简单，容易理解
    * 缺点:
      * 当目标类(厂家)增加, 代理类(商家)可能也需要成倍增加. 代理类数量过多
      * 当接口中的功能增加了 或 修改了, 会影响到很多实现类, 目标类, 代理类 都需要修改

2. 动态代理：
    * 在静态代理中目标类很多的时候, 可以使用动态代理, 可以避免静态代理的缺点。 动态代理中目标类即使很多, 1.代理类可以很少 2.修改接口, 不会影响到代理类
    * 动态代理: 在程序执行过程中, 使用jdk的反射机制, 创建代理类对象, 并动态的指定要代理的目标
    * 换句话说就是: 动态代理是一种创建Java对象的能力, 让你不用创建TaoBao类, 就可以创建代理类对象
    
## JDK动态代理
动态代理是指代理类对象在程序运行期间由JVM根据反射机制动态生成。动态代理不需要指定代理类的.java文件 (静态代理则需要手动编写代理类)  
动态代理其实就是jdk运行期间，动态创建class字节码并加载到JVM。  
动态代理的实现方式常用有两种：
1. 使用JDK动态代理: 使用java反射包java.lang.reflect中的类 和 接口 实现动态代理的功能。
2. 通过CGLIB动态代理: cglib是第三方的工具库, 创建代理对象。cglib的原理是继承, cglib通过继承目标类, 创建它的子类, 在子类中重写父类中的同名方法, 实现功能的修改。  
因为 cglib是继承, 重写方法, 所以要求目标类不能是final, 方法也不能是final  
cglib的要求目标类比较宽松，只要能继承就可以了。cglib在很多框架中使用很多, 比如mybatis, spring

jdk动态代理是基于Java的反射机制实现的。使用jdk中接口和类 实现代理对象的动态创建  
**Jdk的动态要求目标必须实现接口，这是Java设计上的要求**  
从jdk1.3以来, java语言通过 java.lang.reflect 包提供三个类支持代理模式 Proxy, Method 和 InvocationHandler

**动态代理与静态代理的区别:** 我认为最大的区别就是 当一个目标对象(接口) 有 多个实现类时, 静态代理就是需要写很多代理对象(多个类), 每个类实际代理一种 目标对象的实现.  
当目标对象接口有多个方法时, 代理类也是有多个方法的, 每个方法内除调用目标对象实际的方法外, 还需要编写增强的功能  
动态代理的话 就是说 只需要一个代理类, 因为实际的目标对象是通过构造器传入的, 传入的什么目标对象就什么实现. 代理类也只有一个invoke方法, 
根据Method.getName来判断 实际执行的方法, 然后对不同的方法编写不同的增强功能

**我的理解**: 动态代理就是可以在不修改原有代码的基础上新增功能 比如打印日志, 在目标方法执行后 或 执行前   
通过动态代理生成的代理对象 代理 原有的目标类(原有目标类中只包含正常的业务逻辑), 代理对象就可以在原有目标方法执行前 先打印方法信息(记录日志), 然后再执行方法就相当于给目标方法增强功能了

但是我不理解的是, SpringAop那种 一个切面 可以 通过execution表达式 插入多个 切点前, 是怎么通过动态代理实现的.  
多个切点起码是多个类, 一个代理对象可以代理这么多类??? 又或者说是 生成很多代理对象  
然后我使用的 a.select() 实际使用时是 a的代理类.select()所以才会在方法前打印日志???


