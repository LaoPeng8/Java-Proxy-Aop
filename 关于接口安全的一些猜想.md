## 消息鉴别码
消息鉴别码，可以验证消息来源的真实性。**保障消息完整性和真实性的重要手段是消息鉴别技术。**

消息鉴别原理原理: 利用公开函数和密钥生成一个固定大小的小数据块，即MAC，并将其附加在消息之后传输。接收方利用与发送方共享的密钥进行鉴别。
基于MAC提供消息完整性保护，MAC可以在不完全的信道中传输，因为MAC的生成需要密钥。
* 假设通信双发A 与 B (A可以理解为前端, B为后端)，共享密钥 K
* A向B发送消息时，则A计算MAC，将消息与MAC一起发送给接收方B。
* 接收方对收到的消息用相同的密钥K进行相同的计算得出新的MAC，并与接收到的MAC进行比较。
* 如一致则说明消息没有被篡改，如不一致说明消息被篡改了 (或者是密钥被攻击方知道了)
MAC函数与加密类似，但加密算法必须是可逆的，而MAC算法则不要求可逆性。
  
HMAC是受支持的方案，它是一种依赖于密钥的单项哈希函数，同时提供对数据的完整性和真实性的验证。

注：MAC(Message Authentication Code)：消息认证码，是一种带有密钥的hash函数

## 数字签名
数字签名技术是实现交易安全的核心技术之一。
数字签名可以保证实现以下几点：
1. 发送方事后不能否认对发送报文的签名
2. 接收者呢能够核实发送者发送的报文签名
3. 接收者或其他人不能伪造发送者的报文签名
4. 接收者不能对发送者的报文进行部分篡改
数字签名的应用十分广泛，凡是需要对用户的身份进行判断的情况都可以使用数字签名，比如加密信件、商务信函、订货购买系统、远程金融交易、自动模式处理等都可以使用数字签名。
   
使用对称和非对称密码算法都可以实现数字签名，目前采用较多的是公钥机密技术，使用公钥加密技术的签名和验证过程为：
* 发送方(甲) 先用单向哈希函数对某个信息(如合同的电子文件)A进行计算，得到128位的结果B1，再用私钥SK对B进行加密，得到C，该字符串C就是甲对合同A的签名
* 他人(乙) 的验证过程为：乙用单向哈希函数对A进行计算，得到结果，对签名C用甲的公钥进行解密，得到数据串B2，如果B1==B2则签名是真的，反之签名则为假的.

## 关于接口安全的一些猜想
正常来说，登录接口是采用前端验证码 和 后端验证码来控制的。(前端验证码控制前端不被疯狂调用, 如果绕过前端直接请求后端接口就需要后端验证码)，
后端验证码一般通过redis实现即，在用户获取验证码时，后端生成验证码并根据用户的用户名或者手机号为key，存放到redis中，将验证码返回至前端，
前端显示验证码，用户读取输入，后端从redis中取出对应验证码 进行验证 如一致才会正在执行登录逻辑，否则不会执行。 以此来控制 登录接口不被频繁调用。

<br/>

还有一种就是，在一些网站上见过的，如 搜索页面也就是模糊查询的接口，是被控制的 如 一分钟内一个用户只能请求N次，此也能控制 接口不被频繁调用。

<br/>

我觉得就普通的JWT实现的登录就可以控制接口的访问，如登录后返回 代表用户身份的token至前端，之后前端每次请求都带上该token，
后端也是可以通过(过滤器，拦截器)验证该token，验证成功即可以调用该接口，否则就是说不让调用。
（但是就是说如果其他人拿到了这个token，就不知道如何保证了）

<br/>

关于传输数据的安全，即担心前端的json传输到后端时这个json被篡改，就是可以通过 MAC 了.
* 前端将需要发送的 json 使用 MAC 加密, 将加密后的mac字符串 与 json(json可加密可不加密反正就算 它人看见了也篡改不了) 一起发送给后端 (前后端共享一个密钥)
* 后端根据 前端发送的 json 进行 MAC 加密 得到自己的mac字符串, 然后与 前端发过来的mac字符串 进行比较
* 如果一致则 json没有被篡改, 如果不一致则被篡改了.

<br/>

数据签名实现传输文件的安全 (感觉数字签名与MAC大同小异)
* 前端 先用单向哈希函数对某个信息(如合同的电子文件)A进行计算，得到128位的结果B1，再用私钥SK对B进行加密，得到C，该字符串C就是甲对合同A的签名
* 后端 的验证过程为：用单向哈希函数对A进行计算，得到结果，对签名C用前端的公钥进行解密，得到数据串B2，如果B1==B2则签名是真的，反之签名则为假的.

<br/>

不知道为什么, 网上会有这种举例“模拟购物场景，用户点击购物的时候，在前端生成签名信息，传递给后台服务器进行校验，如果价格，数量，签名都正确，购物成功，如果被人修改，购物失败”
我寻思, 买东西时价格数量这种东西不是根据订单来的码, 而且订单信息这种东西也不是前端传来的, 又不是说 前端说是50那么就是50,
是根据订单id来的, 前端传递订单id, 后端根据订单id查询出 订单信息包括价格啥的, 然后根据信息调用微信支付二维码, 然后是多少钱就付多少钱.(支付安全这方面微信肯定是做好的)


## JWT
先说结论, JWT实际上就是使用的 上文中提到的 消息鉴别码实现的

JWT生成的token由三部分组成(每部分之间用 . 间隔)  xxx.yyy.zzz
* 标头（Header）
  * 标头通常由两部分组成：令牌的类型（即JWT）和所使用的签名算法，例如HMAC SHA256或RSA。
  * { "alg": "HS256", "typ": "JWT"}
* 有效负载（Payload）
  * 令牌的第二部分是有效负载，其中包含声明。声明是有关实体（通常是用户）和其他数据的声明。例如用户的name, nickName, sex 等
  * { "sub": "1234567890", "name": "John Doe", "admin": true }
* 签名（Signature）
  * 要创建签名部分，您必须获取编码的标头，编码的有效负载，机密，标头中指定的算法，并对其进行签名。
  * 即 签名是服务端 根据编码后的 header, payload 加上密钥 使用标头中的加密算法如 HMAC 得到的

token的前面两部分都是使用Base64进行编码的，即前端可以解开知道里面的信息。(相当于就是公开可见的, 所以如果不想Payload中的信息除通信双发外的其他人知道, 可以在Payload中直接存储 加密后的字符串)

签名的作用
* 签名的作用是保证JWT没有被篡改过
* 如何保证？ 和 消息鉴别码的机制一样
    * 首先 使用MAC算法如 HmacMD5 和 密钥 对需要防止被篡改的 token第一第二部分 进行加密, 得到第三部分, 然后 一起发送给前端
    * 前端可以通过 base64对第一第二部分进行解码, 得到用户部分信息, 
    * 前端请求后端时带上 该token, 然后后端进行验证
    * 使用 使用MAC算法如 HmacMD5 和 密钥 对token的第一第二部分进行加密, 然后与前端发送过来的 token第三部分进行对比
    * 如一致, 则说明没有篡改
    * 如不一致, 则说明 第一第二部分被篡改了, 或者 第三部分被篡改了







